<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python asyncio 비동기 프로그래밍 완전 가이드</title>
</head>
<body>
    <article>
        <h1>Python asyncio 비동기 프로그래밍 완전 가이드</h1>

        <section id="introduction">
            <h2>1. 비동기 프로그래밍이란?</h2>
            <p>
                비동기 프로그래밍은 작업이 완료될 때까지 기다리지 않고 다른 작업을 수행할 수 있게
                해주는 프로그래밍 패러다임입니다. 특히 I/O 바운드 작업(네트워크 요청, 파일 읽기/쓰기,
                데이터베이스 쿼리 등)에서 효율적입니다.
            </p>
            <p>
                Python의 asyncio 모듈은 async/await 구문을 사용하여 비동기 코드를 작성할 수 있게
                해줍니다. 이를 통해 동기 코드와 유사한 구조를 유지하면서도 높은 동시성을 달성할 수 있습니다.
            </p>
        </section>

        <section id="basics">
            <h2>2. 기본 개념</h2>

            <h3>2.1 코루틴 (Coroutine)</h3>
            <p>
                코루틴은 async def로 정의된 함수입니다. 일반 함수와 달리 호출 시 즉시 실행되지 않고
                코루틴 객체를 반환합니다.
            </p>
            <pre><code>
import asyncio

# 코루틴 정의
async def hello():
    print("Hello")
    await asyncio.sleep(1)  # 비동기 대기
    print("World")

# 코루틴 실행
asyncio.run(hello())
            </code></pre>

            <h3>2.2 await 키워드</h3>
            <p>
                await는 코루틴의 실행을 일시 중지하고 결과를 기다립니다. await는 async 함수 내에서만
                사용할 수 있습니다.
            </p>
            <pre><code>
async def fetch_data():
    await asyncio.sleep(2)  # 2초 대기 (비동기)
    return {"data": "result"}

async def main():
    result = await fetch_data()
    print(result)
            </code></pre>

            <h3>2.3 이벤트 루프 (Event Loop)</h3>
            <p>
                이벤트 루프는 비동기 작업을 스케줄링하고 실행하는 핵심 컴포넌트입니다.
                asyncio.run()은 이벤트 루프를 생성하고 코루틴을 실행합니다.
            </p>
        </section>

        <section id="concurrent">
            <h2>3. 동시 실행</h2>

            <h3>3.1 asyncio.gather()</h3>
            <p>
                여러 코루틴을 동시에 실행하고 모든 결과를 기다립니다.
            </p>
            <pre><code>
import asyncio

async def fetch_data(name, delay):
    print(f"Starting {name}")
    await asyncio.sleep(delay)
    print(f"Finished {name}")
    return f"{name} result"

async def main():
    # 동시에 실행
    results = await asyncio.gather(
        fetch_data("task1", 2),
        fetch_data("task2", 1),
        fetch_data("task3", 3)
    )
    print(results)  # ['task1 result', 'task2 result', 'task3 result']

asyncio.run(main())
            </code></pre>
            <p>
                위 코드에서 세 작업은 동시에 시작되어 총 3초(가장 긴 작업 시간)만에 완료됩니다.
                순차 실행이었다면 6초가 걸렸을 것입니다.
            </p>

            <h3>3.2 asyncio.create_task()</h3>
            <p>
                코루틴을 Task로 스케줄링하여 백그라운드에서 실행합니다.
            </p>
            <pre><code>
async def background_task():
    while True:
        print("Background task running...")
        await asyncio.sleep(5)

async def main():
    # 백그라운드 태스크 생성
    task = asyncio.create_task(background_task())

    # 다른 작업 수행
    await asyncio.sleep(12)

    # 태스크 취소
    task.cancel()
            </code></pre>

            <h3>3.3 TaskGroup (Python 3.11+)</h3>
            <p>
                Python 3.11부터 도입된 구조화된 동시성을 위한 기능입니다.
                컨텍스트 매니저를 벗어나면 모든 태스크가 완료됩니다.
            </p>
            <pre><code>
async def main():
    async with asyncio.TaskGroup() as tg:
        task1 = tg.create_task(fetch_data("task1", 2))
        task2 = tg.create_task(fetch_data("task2", 1))
    # 컨텍스트 매니저를 벗어나면 모든 태스크 완료
    print(task1.result(), task2.result())
            </code></pre>
        </section>

        <section id="patterns">
            <h2>4. 일반적인 패턴</h2>

            <h3>4.1 동시 HTTP 요청</h3>
            <pre><code>
import asyncio
import aiohttp

async def fetch_url(session, url):
    async with session.get(url) as response:
        return await response.text()

async def main():
    urls = [
        "https://api.example.com/data1",
        "https://api.example.com/data2",
        "https://api.example.com/data3",
    ]

    async with aiohttp.ClientSession() as session:
        tasks = [fetch_url(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
        return results
            </code></pre>

            <h3>4.2 타임아웃 처리</h3>
            <pre><code>
async def slow_operation():
    await asyncio.sleep(10)
    return "Done"

async def main():
    try:
        result = await asyncio.wait_for(
            slow_operation(),
            timeout=5.0
        )
    except asyncio.TimeoutError:
        print("Operation timed out!")
            </code></pre>

            <h3>4.3 세마포어로 동시성 제한</h3>
            <pre><code>
async def fetch_with_limit(semaphore, url):
    async with semaphore:
        # 최대 10개의 동시 요청
        return await fetch_url(url)

async def main():
    semaphore = asyncio.Semaphore(10)
    urls = [f"https://api.example.com/{i}" for i in range(100)]

    tasks = [fetch_with_limit(semaphore, url) for url in urls]
    results = await asyncio.gather(*tasks)
            </code></pre>

            <h3>4.4 Producer-Consumer 패턴</h3>
            <pre><code>
async def producer(queue):
    for i in range(10):
        await queue.put(f"item-{i}")
        await asyncio.sleep(0.1)
    await queue.put(None)  # 종료 신호

async def consumer(queue):
    while True:
        item = await queue.get()
        if item is None:
            break
        print(f"Processing {item}")
        await asyncio.sleep(0.2)

async def main():
    queue = asyncio.Queue()
    await asyncio.gather(
        producer(queue),
        consumer(queue)
    )
            </code></pre>
        </section>

        <section id="vs-threading">
            <h2>5. asyncio vs threading</h2>

            <table border="1">
                <tr>
                    <th>특성</th>
                    <th>asyncio</th>
                    <th>threading</th>
                </tr>
                <tr>
                    <td>실행 모델</td>
                    <td>단일 스레드, 협력적 멀티태스킹</td>
                    <td>멀티스레드, 선점형 멀티태스킹</td>
                </tr>
                <tr>
                    <td>컨텍스트 스위칭</td>
                    <td>명시적 (await에서)</td>
                    <td>암묵적 (OS가 결정)</td>
                </tr>
                <tr>
                    <td>GIL 영향</td>
                    <td>영향 없음 (단일 스레드)</td>
                    <td>CPU 바운드에서 제한적</td>
                </tr>
                <tr>
                    <td>오버헤드</td>
                    <td>낮음</td>
                    <td>상대적으로 높음</td>
                </tr>
                <tr>
                    <td>적합한 사용처</td>
                    <td>I/O 바운드, 많은 동시 연결</td>
                    <td>I/O 바운드, 블로킹 라이브러리</td>
                </tr>
                <tr>
                    <td>디버깅</td>
                    <td>상대적으로 쉬움</td>
                    <td>경쟁 조건으로 어려움</td>
                </tr>
            </table>

            <h3>언제 asyncio를 사용할까?</h3>
            <ul>
                <li>많은 수의 동시 연결 처리 (웹 서버, 채팅 서버)</li>
                <li>API 호출이 많은 애플리케이션</li>
                <li>웹 스크래핑</li>
                <li>실시간 데이터 처리</li>
            </ul>

            <h3>언제 threading을 사용할까?</h3>
            <ul>
                <li>동기 라이브러리와 함께 사용해야 할 때</li>
                <li>기존 동기 코드와의 통합</li>
                <li>간단한 병렬 I/O 작업</li>
            </ul>
        </section>

        <section id="best-practices">
            <h2>6. 모범 사례</h2>

            <h3>6.1 블로킹 코드 피하기</h3>
            <p>
                async 함수 내에서 블로킹 호출(time.sleep(), requests.get() 등)을 사용하면
                전체 이벤트 루프가 블로킹됩니다. 대신 비동기 대안을 사용하세요.
            </p>
            <pre><code>
# 나쁜 예
async def bad_example():
    time.sleep(1)  # 블로킹!

# 좋은 예
async def good_example():
    await asyncio.sleep(1)  # 비동기
            </code></pre>

            <h3>6.2 run_in_executor로 블로킹 코드 실행</h3>
            <p>
                블로킹 코드를 반드시 사용해야 할 때는 executor에서 실행하세요.
            </p>
            <pre><code>
import asyncio
from concurrent.futures import ThreadPoolExecutor

def blocking_io():
    # 블로킹 I/O 작업
    import time
    time.sleep(1)
    return "result"

async def main():
    loop = asyncio.get_event_loop()
    result = await loop.run_in_executor(
        None,  # 기본 executor 사용
        blocking_io
    )
    print(result)
            </code></pre>

            <h3>6.3 예외 처리</h3>
            <pre><code>
async def main():
    try:
        results = await asyncio.gather(
            task1(),
            task2(),
            return_exceptions=True  # 예외를 결과로 반환
        )
        for result in results:
            if isinstance(result, Exception):
                print(f"Task failed: {result}")
            else:
                print(f"Task succeeded: {result}")
    except Exception as e:
        print(f"Error: {e}")
            </code></pre>

            <h3>6.4 리소스 정리</h3>
            <pre><code>
async def main():
    async with aiohttp.ClientSession() as session:
        # 세션 사용
        pass
    # 컨텍스트 매니저가 자동으로 정리
            </code></pre>
        </section>

        <section id="debugging">
            <h2>7. 디버깅</h2>

            <h3>디버그 모드 활성화</h3>
            <pre><code>
# 방법 1: 환경 변수
# PYTHONASYNCIODEBUG=1 python script.py

# 방법 2: 코드에서
asyncio.run(main(), debug=True)
            </code></pre>

            <h3>유용한 디버깅 팁</h3>
            <ul>
                <li>await 누락 경고 확인</li>
                <li>느린 콜백 감지</li>
                <li>취소되지 않은 태스크 추적</li>
            </ul>
        </section>

        <footer>
            <h2>참고 자료</h2>
            <ul>
                <li>Python 공식 문서: asyncio</li>
                <li>Real Python: Async IO in Python</li>
                <li>aiohttp 공식 문서</li>
            </ul>
        </footer>
    </article>
</body>
</html>
